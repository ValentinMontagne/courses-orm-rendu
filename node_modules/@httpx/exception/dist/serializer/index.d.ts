import { h as HttpValidationIssue, W as HttpMethod, H as HttpErrorStatusCodeOrNumber, f as HttpException } from '../HttpClientException-6qDwRaH4.js';

declare class SerializerError extends Error {
    constructor(message: string, params?: {
        cause?: Error;
    });
}

/**
 * Supported native ecmascript errors
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types
 * @see https://262.ecma-international.org/12.0/#sec-well-known-intrinsic-objects
 */

type NativeError = Error | EvalError | RangeError | ReferenceError | SyntaxError | TypeError | URIError;
type DiscriminateSerializable<T extends Serializable['__type']> = Extract<Serializable, {
    __type: T;
}>;
type SerializerParams = {
    /**
     * Whether to include stack strack trace in serialized data
     */
    includeStack?: boolean;
};
type NativeErrorFields = {
    cause?: Serializable;
    /** Error message (a string, non-empty with HttpException subclasses) */
    message: string;
    /** Class name, ie: Error, RangeError, HttpException, HttpBadRequest */
    name: string;
    stack?: string;
};
type HttpExceptionFields = NativeErrorFields & {
    code?: string;
    errorId?: string;
    issues?: HttpValidationIssue[];
    method?: HttpMethod;
    statusCode: HttpErrorStatusCodeOrNumber;
    url?: string;
};
type Serializable = ({
    __type: 'HttpException';
} & HttpExceptionFields) | ({
    __type: 'NativeError';
} & NativeErrorFields) | ({
    __type: 'NonNativeError';
} & NativeErrorFields);
type SerializableHttpException = DiscriminateSerializable<'HttpException'>;
type SerializableError = DiscriminateSerializable<'NativeError'>;
type SerializableNonNativeError = DiscriminateSerializable<'NonNativeError'>;

declare const fromJson: (json: string, params?: SerializerParams) => Error | HttpException | SerializerError;

declare const toJson: (exception: Error | HttpException | NativeError, params?: SerializerParams) => string;

/**
 * Convert an Error, NativeError or any HttpException to
 * an object suitable for serialization (a serializable version).
 *
 * @link {createFromSerializable}
 */
declare const convertToSerializable: (e: Error | HttpException | NativeError, params?: SerializerParams) => Serializable;

/**
 * create an Error, NativeError or any HttpException from a
 * serializable representation
 *
 * @link {convertToSerializable}
 */
declare const createFromSerializable: (payload: Serializable, params?: SerializerParams) => Error | HttpException | NativeError;

export { type NativeError, type SerializableError, type SerializableHttpException, type SerializableNonNativeError, SerializerError, convertToSerializable, createFromSerializable, fromJson, toJson };
